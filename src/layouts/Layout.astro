---
import siteConfig from '@config/site';
import {
  DEFAULT_LOCALE,
  SUPPORTED_LOCALES,
  getLocaleDirection,
  getLocaleFlag,
  getLocaleLangTag,
  getLocaleLabel,
  resolveLocaleDefinition,
} from '@config/locales';
import {
  getEnabledCategoryIds,
  getPageByTranslationKey,
  getPagePermalink,
} from '@lib/content';
import { isDefaultLocale } from '@lib/language';
import { ensureTrailingSlash } from '@utils/url';
import { getLangFromUrl, useTranslations, useTranslatedPath } from '@i18n/utils';
import PageHead from '@components/layout/PageHead.astro';
import SiteHeader from '@components/layout/SiteHeader.astro';
import MobileMenu from '@components/layout/MobileMenu.astro';

type AlternateLink = {
  lang: string;
  url: string;
};

type LayoutProps = {
  title?: string;
  description?: string;
  keywords?: string;
  image?: string;
  prevPageUrl?: string;
  nextPageUrl?: string;
  alternates?: AlternateLink[];
};

const {
  title,
  description,
  keywords,
  image,
  prevPageUrl,
  nextPageUrl,
  alternates = [],
}: LayoutProps = Astro.props;

const requestedLang = getLangFromUrl(Astro.url);
const currentLocaleDefinition = resolveLocaleDefinition(requestedLang);
const lang = currentLocaleDefinition.code;
const t = useTranslations(lang);
const translatePath = useTranslatedPath(lang);

const pathname = ensureTrailingSlash(Astro.url.pathname);
const baseDomain = siteConfig.siteUrl;
const canonicalUrl = new URL(pathname, baseDomain).toString();

const categories = getEnabledCategoryIds();

const escapeRegExp = (value: string) => value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
const localePathPattern = SUPPORTED_LOCALES.map(escapeRegExp).join('|');

const parsedAlternates = alternates.map(({ lang, url }) => {
  try {
    return { lang, pathname: new URL(url, baseDomain).pathname };
  } catch {
    return { lang, pathname: url };
  }
});

const alternateMap = new Map<string, string>();

parsedAlternates.forEach(({ lang: alternateLang, pathname }) => {
  const normalizedPath = ensureTrailingSlash(pathname);
  const definition = resolveLocaleDefinition(alternateLang);

  const variants = [
    alternateLang,
    alternateLang.toLowerCase(),
    definition.code,
    definition.code.toLowerCase(),
    definition.langTag,
    definition.langTag.toLowerCase(),
  ].filter(Boolean) as string[];

  variants.forEach((variant) => {
    alternateMap.set(variant, normalizedPath);
  });
});

function getLocalePath(targetLang: string): string {
  const mapped = alternateMap.get(targetLang);
  if (mapped) {
    return mapped;
  }

  const normalizedPath = pathname === '/' ? '' : pathname.replace(/^\//, '');
  const isCurrentDefault = isDefaultLocale(lang);
  const contentSlug = isCurrentDefault
    ? normalizedPath
    : normalizedPath.replace(new RegExp(`^${escapeRegExp(lang)}/`), '');

  if (targetLang === DEFAULT_LOCALE) {
    const defaultPath = contentSlug ? `/${contentSlug}` : '/';
    return ensureTrailingSlash(defaultPath);
  }

  const candidatePath = contentSlug
    ? ensureTrailingSlash(`/${targetLang}/${contentSlug}`)
    : ensureTrailingSlash(`/${targetLang}/`);

  if (pathname === candidatePath) {
    return candidatePath;
  }

  return ensureTrailingSlash(`/${targetLang}/`);
}

const localeOptionKeys = SUPPORTED_LOCALES.map((code) => resolveLocaleDefinition(code));
const normalizedActiveCode = lang.toLowerCase();

const languageOptions = localeOptionKeys.map((definition) => {
  const code = definition.code;
  const langTag = definition.langTag;
  const codeLower = code.toLowerCase();
  const langTagLower = langTag.toLowerCase();

  const isActive = codeLower === normalizedActiveCode || langTagLower === normalizedActiveCode;
  const isAvailable =
    isActive ||
    alternateMap.has(code) ||
    alternateMap.has(codeLower) ||
    alternateMap.has(langTag) ||
    alternateMap.has(langTagLower);

  const fallbackHref =
    code === DEFAULT_LOCALE ? '/' : ensureTrailingSlash(`/${code}/`);
  const href = isAvailable ? getLocalePath(code) : fallbackHref;

  return {
    code,
    label: getLocaleLabel(code),
    displayLabel: getLocaleFlag(code),
    href,
    isActive,
    isAvailable,
  };
});

const htmlLang = getLocaleLangTag(lang);
const htmlDir = getLocaleDirection(lang);

function isPostListPage(): boolean {
  const pathname = Astro.url.pathname;
  const paginatedHome = new RegExp(`^/(?:${localePathPattern}/)?(\\d+/?)?$`);
  if (pathname === '/' || paginatedHome.test(pathname)) {
    return true;
  }

  if (!categories.length) {
    return false;
  }

  const categoryPattern = categories.map(escapeRegExp).join('|');
  const categoryRegex = new RegExp(
    `^/(?:${localePathPattern}/)?(${categoryPattern})(/\\d+/?)?$`
  );
  return categoryRegex.test(pathname);
}

const showSearch = isPostListPage();

const siteTitleLocalized =
  siteConfig.title[lang] ?? siteConfig.title[DEFAULT_LOCALE];

const metaTitle = title ?? siteTitleLocalized;
const metaDescription =
  description ??
  siteConfig.description[lang] ??
  siteConfig.description[DEFAULT_LOCALE];
const ogImage = image && image.startsWith('http')
  ? image
  : `${baseDomain}${image ?? siteConfig.seo.defaultImage}`;

const twitterHandle = siteConfig.seo.twitterHandle
  ? `@${siteConfig.seo.twitterHandle.replace(/^@/, '')}`
  : undefined;

const toAbsolute = (url?: string) =>
  url ? new URL(ensureTrailingSlash(url), baseDomain).toString() : undefined;

const prevAbsolute = toAbsolute(prevPageUrl);
const nextAbsolute = toAbsolute(nextPageUrl);
const fallbackDescription = t('ui.description');
const homeHref = ensureTrailingSlash(`/${isDefaultLocale(lang) ? '' : lang}`);

type ResolvedNavItem = {
  id: string;
  href: string;
  label: string;
};

const resolveNavItems = async (): Promise<ResolvedNavItem[]> => {
  const configs = siteConfig.navigation ?? [];
  if (!configs.length) {
    return [];
  }

  const results = await Promise.all(
    configs.map(async (item) => {
      const translatedLabel =
        (item.labelKey ? t(item.labelKey as any) : null) ?? undefined;
      const fallbackLabel =
        item.labelKey ?? item.id;
      const label =
        item.label?.[lang] ??
        item.label?.[DEFAULT_LOCALE] ??
        translatedLabel ??
        fallbackLabel;

      if (item.translationKey) {
        const localizedEntry = await getPageByTranslationKey(item.translationKey, lang);
        if (localizedEntry) {
          return {
            id: item.id,
            href: getPagePermalink(localizedEntry),
            label,
          };
        }

        const fallbackEntry = await getPageByTranslationKey(
          item.translationKey,
          siteConfig.defaultLanguage,
        );

        if (fallbackEntry) {
          return {
            id: item.id,
            href: getPagePermalink(fallbackEntry),
            label,
          };
        }

        return null;
      }

      if (item.path) {
        const normalized = item.path.startsWith('/') ? item.path : `/${item.path}`;
        return {
          id: item.id,
          href: translatePath(normalized),
          label,
        };
      }

      if (item.external) {
        return {
          id: item.id,
          href: item.external,
          label,
        };
      }

      return null;
    }),
  );

  return results.filter((value): value is ResolvedNavItem => Boolean(value));
};

const navItems = await resolveNavItems();
---
<!DOCTYPE html>
<html lang={htmlLang} dir={htmlDir}>
  <PageHead
    lang={lang}
    title={metaTitle}
    description={metaDescription}
    keywords={keywords}
    canonicalUrl={canonicalUrl}
    alternates={parsedAlternates}
    prev={prevAbsolute}
    next={nextAbsolute}
    ogImage={ogImage}
    twitterHandle={twitterHandle}
    baseDomain={baseDomain}
    fallbackDescription={fallbackDescription}
  />
  <body>
    <div class="page">
      <SiteHeader
        lang={lang}
        siteTitle={siteTitleLocalized}
        homeHref={homeHref}
        navItems={navItems}
        languageOptions={languageOptions}
        showSearch={showSearch}
        enableDarkMode={siteConfig.features.darkMode}
      />

      <MobileMenu lang={lang} navItems={navItems} languageOptions={languageOptions} />

      <main class="main">
        <div class="cont">
          <slot />
        </div>
      </main>
    </div>
  </body>
</html>
